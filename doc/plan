{
 '_id': 'c063d45413da11e194ca0026c7d605c8',
 'keys': {#Either value may be omitted or null to allow for anonymous access
  'read': 'WiyzwKI_3PBO9VSL0cr', #A random-length string that must be provided
                                 #to access the file from an untrusted context
  'write': 'DekI-LoRfc!', #And another is used to make changes
 },
 'physical': { #index ctime, atime, family
  'family': 'voice'/null, #The family to which the data belongs; if omitted,
                          #null, or unmapped, the generic backend is used;
                          #otherwise, allows for partitioning if the family is
                          #mapped in config
  'ctime': 1321836553.0, #Path generated by decomposition with mktime()
                         #/2011/11/21/12/30/<uid>[.ext][.compression-ext]
  'minRes': 5, #Minute sub-division in use when the record was created
  'atime': 1321836554, #Time at which the file was last accessed
  'format': {
   'mime': 'audio/x-wav',
   'comp': 'gz'/'bz2'/'lzma'/null, #Omitted or null -> no compression
   'ext': null/'wav', #Omitted or null -> no extension
  },
 },
 'policy': {
  'delete': { #index fixed, stale
   'fixed': 1321836555, #Time after which file should be deleted; this field
                        #may be omitted or null to disable
   'stale': 3600, #The number of seconds that must lapse after the file's atime
                  #to qualify it for deletion; may be omitted or null
   'staleTime': 1321836855, #The time at which the record will be considered stale
  },
  'compress': { #index fixed, stale
   'fixed': 1321836555, #Time after which file should be compressed; this field
                        #may be omitted or null to disable
   'stale': 3600, #The number of seconds that must lapse after the file's atime
                  #to qualify it for compression; may be omitted or null
   'comp': 'gz'/'bz2'/'lzma', #The compression format to use;
                                     #decompression occurs if necessary
   'staleTime': 1321836855, #The time at which the record will be considered stale
  }, #This section is emptied after compression occurs
 },
 'stats': {
  'accesses': 1, #Number of times the file has been accessed
 },
 'meta': {
  'key': 'value'/5/42.7, #Typical key-value store; when querying, the interface
                         #must have the operator specify the type of field so
                         #the client can build an appropriate JSON object
  ...
 },
}

Queries against the following non-meta fields are supported through explicit
constructs:
- ctime (range)
- atime (range)
- family (match)
- mime (super-type or both)
- accesses (gte, lte, eq)

Query syntax (against meta):
- For matching queries, no special syntax exists or is needed (the library will
  use proper JSON encoding)
- Range queries are supported only over numeric types: ':range:<min>:<max>',
  inclusive on both ends
- Directional queries are given for numeric types, too: ':lte:<number>' and
  ':gte:<number>'
- Regular expressions are supported over strings, as a search: ':re:<pcre>' and
  ':re.i:<pcre>' (insensitive)
- For operators used to SQL, a subset of regular expressions is provided,
  offering case-insensitive searching with wildcards: ':like:<pattern>'
- If you actually want to start a string with one of the special operators
  (everything between two colons is reserved), start it with '::'; the first
  colon will be ignored

Architecture:
- Server (python, tornado, mongo, PyLZMA, and a filesystem; nginx recommended
  for file proxying)
 - Runs periodic delete/compression sweeps
 - Occasionally validates on-disk content against data-store, purging broken
   records
  - This runs both ways, as two different actions
- Proxy (python, BaseHTTPServer, local filesystem)
 - Issues UIDs on behalf of central servers (one proxy can serve many),
   allowing applications to hand off responsibility
  - Internally ensures that the file is delivered in a timely fashion,
    protecting against network or remote failures
 - Transfers file-content via the filesystem, making a copy of the original
   file in a local cache, along with metadata, for deferred delivery
- Client (all languages)
 - Offers two implementations of the storage interface:
  - Proxy:
   - Allows for files to be submitted as streams or as filesystem entities,
     transparently dumping the stream to disk if necessary
   - Notifies the local proxy of the file's location and metadata
   - Returns a UID
   - Cleans up the tempfile, if one was created
  - Server:
   - Accepts files as streams or filesystem entities, serialising the content
     as a half-JSON, half-binary package
   - Returns a UID if one was not supplied (proxies use this; applications
     must not)
  - Both:
   - Have an option for removing the on-disk file, in file-mode
   - Do NOT do mime/extension introspection (the application is responsible)
 - Offers a query interface:
  - Returns a list of file descriptors (identical to the data-structure above)
 - Offers a download interface:
  - Grab file as stream
  - Store file to disk
 - Offers a management interface:
  - Delete file
  - Compress file
  - Set policy options
  - Set/unset meta attributes
 - Is fully subclassable, allowing for specialised variants (like caching
   clients that use meta attributes)

Filesystem support:
- Local:
 - POSIX
 - Win32
- Remote
 - SFTP (paramiko)

Expansion:
Families can be used to permit multiple local partitions or remote resources to
be used in tandem, which should be enough for most users; a new family may be
defined at any time and a partition may be added afterwards or before (if
added afterwards, the new particion will require that all content be transferred
before it can be used).

When a family's partition aproaches capacity, if content cannot be deleted,
increasing size is a fairly straightforward matter of copying all on-disk
content to the new storage location, updating the family backend specifier,
and restarting the service, performing another incremental copy for
synchronisation after the restart. Any files deleted on the old store between
operations will be cleaned up in successive orphan scans.

Lastly, though one instance of the service should be enough for most
environments, multiple hosts could run their own media-storage system, with
their own families and backends, each offering its own resource namespace.
While a single host could run multiple services on different ports, this is
probably not a good idea, since ports and busses will be contested; the only
viable use cases for this are lightly loaded hosts where discrete namespaces
are a must and lightly loaded I/O-strong hosts that have multiple weak processor
cores.

Of course, if running behind an nginx front-end, load-balancing one or
two instances per processor core will likely provide higher performance; to do
this, create a global config file and a separate one that only overrides the HTTP
port, log path, and maintenance schedules for each instance, then supply the path
of the specialised file as an argument.

Redundancy:
Because every operation in this system is stateless and atomic, no update will
ever be left in a half-completed state. This makes redundant deployments very
easy.

A good, simple strategy would be to have at least two hosts VRRPed, each
running a full replicant of the database (in precedent order equal to VRRP) and
sharing a single, heavily-RAIDed data-store (like a SAN resource).

Regardless of which server takes a request, it will be served and globally
visible, and the failure of one host will, at worst, interrupt any active
transfers, but not commit anything. The client will receive a timeout event in
such a case.

Similarly, this would allow either host, or all, to beshut down at will without
compromising the environment. (Worst-case: clients need to try their upload
again later, which is where the proxy comes in)

Security:
This system was designed with the assumption that network-level protection
would be sufficient for most cases, with UUID obscurity and a need for
contextual knowledge deterring scans. DoSes have not been addressed at this
time, though nginx and tornado both handle high connection volumes well and
nginx can refuse files above a certain size, without wasting memory.

The proxy is fairly well protected because it will listen only on the localhost
interace, meaning the box itself would need to be compromised to allow it to
come under attack.

If an environment requires stronger security measures (credentials,
handshakes), the server's base handler may be modified; its structure is not
expected to change, so patches will have considerable longevity.

To avoid query attacks, queries will be capped at some nominal record-count
(configurable : 100), requiring operators to provide more specific queries to
see the records they want. (This number must be large enough to contain what
is desired, but not so large that it makes I/O choke)

Since the query mechanism is shared between operators and extending maintenance
scripts, any scripts that do not modify or destroy records to make them invalid
candidates for successive queries must supply a 'ctime_max' or 'ctime_min'
property to bypass the first chunk of matching records; either is compared as a
greater/lesser-than, not a greater/lesser-than-equal. (This property is used to
allow a range-based query over the ctime index, which is pretty efficient)

Backups:
Copy the config file, dump the database, and incrementally copy the datastores.
Easy.

